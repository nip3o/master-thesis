
\subsection{Evolution of test execution time}

As seen in \fref{sec:results_time}, the execution time of the RSpec
integration- and unit tests has decreased for every part of the case
study, even though the number of tests has increased. On average, each
test is more than twice as fast after the second part compared to before
the case study.\\

The major reason for the increase of speed comes from the refactoring of
old tests, initiated in the first part of the case study. Some old tests
was also re-factored during the second part, which explains the decrease
in test execution time between the first and the second part of the case
study. One reason for the drop in average execution time after the
second part was also the fact that a few more unit-tests was written,
compared to before.\\

The single most important factor for speeding up tests when re-factoring
the old tests was to reduce the construction of database objects. Before
the case-study, all test data for all tests was created before every
test, since the database needs to be cleaned between each test in order
for one test not to affect other tests. By using factory objects, we
could instead only create the objects needed for each specific test,
instead of creating a huge amount of data which is not even used. RSpec
also caches factory objects between tests which uses the same objects,
which gives some additional speed gain.\\

By looking at the execution times for the Cucumber feature test, it
might seem like these tests became a great deal slower after the first
part of the case-study. One issue is however that Cucumber stops
executing a test as soon as some part of the test fails. Since almost
all of the tests failed at an early stage, large part of the test suite
was never executed and the execution time before the first part of the
case study is therefore misleading.\\


\subsection{Execution time of different test types}


