
I have striven for using test- and behavioral-driven development
methodologies in the strictest possible way throughout this entire
thesis. The purpose of this has been to gain experience of different
advantages and drawbacks of these methodologies. In situations where I
have found these methodologies to be unsuitable, I have however chosen
to disregard some principles of these methodologies rather than try to
apply them anyway.\\

Using a test-driven approach has two major advantages in our opinion.
The most important is perhaps that it alleviates a sense of fear about
whether or not the implementation really works as it is supposed to, and
a fear that things may break when the code is refactored. The second
important aspect is that the written code is self-testing; one can run a
command in order to find out whether or not the code is in a working
state, rather than testing it manually and see what happens. In
particular, I found writing a failing test before fixing a software
defect to be especially helpful. One can instantly see when the defect
was fixed and therefore know when the work is done, and do not have to
constantly test the software manually during development.\\

Another benefit from using the test-first principle is that one often
think through the design before the implementation. The implementation
has to be written in such way that it is testable, which makes the
developer discover new ways of solving the problem and design the
software better. In some cases this also reduces the amount of written
code since we strive to minimize the number of cases that we have to
test. Additionally, I personally find it tedious to write tests after
the implementation is done. My opinion is that writing the tests first
makes the development more fun than writing tests after
implementation.\\

There is however no guarantee that a more testable design is better than
a less testable design. For example, making it possible to test a
module may require using of a large amount of fake objects such as
mocks. It might also be required to split up the module into several sub
modules that does not map very well to the real world and thus are
difficult to understand. I believe that it is better to test on a
higher level and perhaps discard the test-first principle in cases where
making the code testable introduces more drawbacks than advantages to
the overall design.\\

My main difficulty while using TDD was the \emph{refactor}-part of the
\emph{Red, green, refactor} mantra. I found it hard to know whether or
not code needed to be refactored, and to know how large part of the code
to refactor. Some small changes required large parts of the code to be
refactored in order for the code to be possible to unit-test. In some
situations I found that the overhead of doing refactoring simply was so
large that I decided not to do any refactoring at all. One reason for
this may be that the old implementations have been written without
testability or test-driven development in mind. The need for heavy
refactoring would probably decrease over time if test-driven
methodologies were used.\\

My experiences from using behavior-driven development principles are
generally positive. I found that using descriptive strings for tests
(rather than function names) forced me to split up tests into smaller
parts, since each part must be possible to describe with a single
sentence. It also felt natural to share preconditions (such as \emph{if
the user is logged in}) for a set of tests using a string. One drawback
is however that the full string for a test, including preconditions,
tends to be very long. This can make it harder to perceive which of the
tests that failed.\\

While using descriptive strings for describing tests and preconditions
in general worked very well, while using a ubiquitous language when
writing and reading tests felt unnatural. I experienced that the
resulting test stories was hard to read and understand, and I could not
see any gain from using it in this particular project. It might be worth
considering for large software development projects with many roles and
multiple stakeholders, but hardly for projects like the GOLI application
where the developers are in charge of feature specifications as well as
testing and implementation.\\
