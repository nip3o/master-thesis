
This chapter presents some final thoughts and reflections on the results
and summarizes the previously discussed conclusions. A summary of my
proposed solution for testing a web application is also presented.\\

\section{General conclusions}

\begin{itemize}

\item  Working with the chosen testing frameworks (RSpec and Jasmine)
has worked very well for testing the GOLI application in particular. I
believe that it would also work very well for testing most similar web
applications.\\

\item The experience of using test-driven development as well as some
ideas originating from behavior-driven development has been pleasant.
While this is a subjective opinion, I believe that this might be the
case for many other software developers and for other projects as well.
I have also found that the newly implemented functionality is well
tested and that its test efficiency is high, which may be another
benefit from using these methodologies. Writing tests using a
ubiquitous language was however not beneficial for this particular
application.\\

\item The combination of many integration- and unit tests complemented
by a few browser tests was successful for this project. It might however
be hard to determine the best level of testing for certain
functionality.\\

\item The level of testing and the combination of different kinds of
tests basically depends on the application. It is not possible to say
that writing higher-level unit- or integration- test is generally worse
than writing lower-level unit tests, nor the contrary. Using browser
tests as the primary testing method is probably not the best solution
for most projects, however.\\

\item A test suite can speed up significantly by using factories to
crate data before each test rather than manually create data for all
tests when the test suite is initialized. While tests using the database
are still not in the same magnitude of speed as low-level unit tests,
they are still fast enough to be usable for using test-driven
development methodologies.\\

\item Using metrics for test efficiency such as test coverage is usable
for finding parts of the code that lacks testing, in order to make tests
better. I believe that using statement test coverage may work well
practice, even if branch coverage is more helpful and returns more fair
coverage percentages. The increased test efficiency could possibly lead
to finding more software defects due to more efficient tests, but I have
not found any defects by using test efficiency metrics in this
project.\\

\end{itemize}

\newpage
\section{Suggested solution for testing a web application}

For a web application with at least some amount of client-side and
server-side code, I would recommend unit testing for the client as well
as the server. In addition, system-level browser tests should be used.
Most of the written tests should be on unit- and integration-
tests, but the exact proportions depend on the application.\\

I would recommend applications that use Javascript or CoffeeScript on
the client side to use the Jasmine testing framework together with the
Karma test runner. For testing the client-side in Rails projects,
Teaspoon could be an alternative to Karma, which is discussed in
\fref{sec:js_test}.\\

A server-side written in Ruby on Rails could be tested using RSpec, with
factory\_girl for generating test data. Rails controllers can preferably
be tested using higher-level tests, while model instance methods often
can be tested using lower-level unit tests. This is discussed more
thoroughly in \fref{sec:ruby_test}.\\

Selenium is highly useful for system-level tests. I would however
recommend using a higher-level framework such as Capybara rather than
using Selenium directly. The page object pattern should also be used.
SitePrism is useful for this purpose. These frameworks are discussed
further in \fref{sec:choices_browser}.\\
